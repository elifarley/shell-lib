#!/usr/bin/env bash
CMD_BASE="$(readlink -f $0)" || CMD_BASE="$0"; CMD_BASE="$(dirname $CMD_BASE)"
PATH="$CMD_BASE:$PATH"

generate_dockerfiles() {
  local dockerfile_dir="$(readlink -f "${1:-.}")"; shift
  local ptype="$1"; shift

  cat >"$dockerfile_dir"/.dockerignore <<-'EOF'
**~
**.DS_Store
**.log
.idea
target
coverage
spec
test
.rspec
.rubocop*
EOF

  test -f "$dockerfile_dir"/Dockerfile && return

  case "$ptype" in
    ruby)
      image_parent='elifarley/docker-rails:rails-4.2.5.1' ;;
    nodejs)
      image_parent='elifarley/docker-dev-env:debian-node-onbuild' ;;
    python)
      image_parent='elifarley/docker-dev-env:alpine-sshd-python-2.7' ;;
    jvm*)
      image_parent='elifarley/docker-cep:alpine-jdk-8-copycontext' ;;
    *)
      return 1
  esac

  cat > "$dockerfile_dir"/Dockerfile <<-EOF
FROM $image_parent
MAINTAINER http://github.com/elifarley/shell-lib
ENV BASE_IMAGE='$image_parent'

EXPOSE 8080
#

EOF
}

generate_dockerfile_and_archive() {
  local project_root="$(readlink -f "${1:-.}")"; shift
  local ptype="$(project-type "$project_root")"
  export PROJECT_TYPE="$ptype"

  local dockerfile_dir="$project_root"
  local tar_params=()
  local all_included=''
  test "$ptype" = jvm && {
    dockerfile_dir="$project_root"/target
    local gradle_dist
    gradle_dist="$(find "$project_root"/build/distributions -name '*.tar')" && \
      ptype=jvm:gradle
  }
  case "$ptype" in
    jvm:gradle)
      tar_params+=(.); all_included=T
      local app_exec
      tar --strip-components=1 -xf "$gradle_dist" -C "$dockerfile_dir" || return
      app_exec="$(find "$dockerfile_dir"/bin -mindepth 1 ! -type d ! -name '*.*')" && test -x "$app_exec" || {
        echo "Unable to find Gradle-generated executable at '"$dockerfile_dir"/bin':"
        find "$dockerfile_dir"/bin -mindepth 1 ! -type d ! -name '*.*' -exec ls -lhFa {} +
        return 1
      }
      ;;
    jvm)
      local appfiles=("$dockerfile_dir"/*app*.sh)
      tar_params+=("${appfiles[@]#"$dockerfile_dir"/}")
      local jars=("$dockerfile_dir"/*.jar)
      test ${#jars[@]} -gt 1 && tar_params+=("${jars[@]#"$dockerfile_dir"/}") || {
        test -f "$dockerfile_dir"/app.jar || {
          mv "$dockerfile_dir"/*.jar "$dockerfile_dir"/app.jar || return
        }
        tar_params+=(app.jar)
      }
      ;;
    *) tar_params+=(.); all_included=T ;;
  esac

  case "$ptype" in
    jvm*) test -e "$dockerfile_dir"/app.sh && echo "'app.sh' already exists" || {
      cp -v "$CMD_BASE"/jvm-loader.sh "$dockerfile_dir"/app.sh || return
    } ;;
  esac

  local extra_files='Dockerfile .dockerignore'
  test "$project_root" != "$dockerfile_dir" && \
    for item in $extra_files; do
      test -f "$dockerfile_dir/$item" && continue
      test -f "$project_root/$item" || continue
      cp -v "$project_root/$item" "$dockerfile_dir"
    done

  generate_dockerfiles "$dockerfile_dir" "$ptype" || return

  test "$all_included" || \
    for item in $extra_files; do
      test -f "$dockerfile_dir/$item" && tar_params+=("$item")
    done

  archive-project-artifacts "$dockerfile_dir" . "${tar_params[@]}"
}

test "$DEBUG" && set -x
generate_dockerfile_and_archive "$@"
